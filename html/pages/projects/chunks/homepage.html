<h1>About this site</h1>

<div class="list--underscored">
  <ul>
    <li><a href="">on github</a></li>
  </ul>
</div>

<p>
This site is a custom built, single page app built using <a href="https://nodejs.org/">node</a> and <a href="http://browserify.org/">browserify</a>.  It's all javascript and static html, there is no backend. There are custom build steps for development and production.  And a <a href="#">super simple deploy command</a>.
</p>

<h3>on page load:</h3>

<p>
Each "page" is saved as an html snippet (see the snippet driving this page <a href="#">here</a>).  When routed to "/pages/projects/homepage.html", the app will load the snippet and display it inside of the layout. I've built in two optimizations to this process:
</p>

<ol>
  <li>
    <p>
    If you navigate directly to "/pages/projects/homepage.html", then the default behavior is not ideal. You would load the page skeleton, then the application javascript.  The javascript would then detect the url and make an ajax request for the specified html snippet.  Displaying the snippet would be the last action taken. <i>This is backwards.</i> The text you requested should be the <i>first</i> thing displayed.
    </p>

    <p>
  To optimize the page load, the build step takes each html snippet and renders it inside the skeleton. It saves this page in the appropriate location. So, when you navigate directly to "/pages/projects/homepage.html", the first thing you load is the article text.  The application javascript is loaded last.
    </p>
  </li>

  <li>
    <p>
    In order to speed up navigation, I built a "cache machine" (I'm really proud of that name...) to pre-fetch all snippets.  Check out the network pane in the developer tools to see it in action.
    </p>
  </li>
</ol>


<h3>the terminal:</h3>

<p>
All commands are run through the terminal, even navigation. It has a registry of commands, using regular expressions to find the correct handler. Each handler can operate synchronously or asynchronously.
</p>

<p>
There is no easy way to use css to create the "block caret" that's found in the terminal, so I built <a href="#">my own input element</a>.  This does not work on mobile, because there is no way to use javascript to show the keyboard. I tried using hidden inputs to trick mobile browsers into showing the keyboard, but it gets ugly very quickly.
</p>

<p>
Each command run has the option to remain in control of the terminal.  All subsequent input is piped to that command.  Try running "adventure" to see a process take over the terminal.
</p>
