var Deferred = require('jquery').Deferred;
var TIMEOUT = 10000;

//options:
//
//  matcher:
//    RegExp or function: returns a truthy/falsey value
//    indicating whether this command handles the given input
//  fn:
//    function: To be run if the command handles the input.
//
//    Returns a truthy value if the command is asynchronous.
//    An asynchronous command must resolve the promise itself.
//
//    A falsey value indicates that the command is finished,
//    and we automatically resolve the promise.

function Command(options){
  this.matcher = options.matcher;
  this.fn = options.fn;
  this.kill = options.kill;
  this.priority = options.priority || 5;
}

Command.prototype.isHandler = function(input){
  return !!matchOn.call(this, input);
};

Command.prototype.run = function(input) {
  var match, deferred, isAsync;
  deferred = new Deferred();

  match = matchOn.call(this, input);
  isAsync = this.fn(match, deferred);

  if (! isAsync){
    // if the promise is already resolved,
    // then this is a no-op
    deferred.resolve(false);
  }

  setTimeout(expire.bind(this, deferred), TIMEOUT);

  return deferred.promise();
};

//private, must be bound

var matchOn = function(input){
  if (this.matcher instanceof RegExp) {
    return input.match(this.matcher);
  }
  else {
    return this.matcher(input);
  }
};

var expire = function(deferred){
  if (deferred.state() !== 'pending'){
    return;
  }

  if (this.kill){
    this.kill();
  }
  else {
    // Some commands are used during construction of terminal
    var terminal = require('app/terminal/model');
    terminal.warn('This operation has timed out');
  }

  // Commands should use this flag to determine
  // whether they can still write to the terminal.
  this.killed = true;

  deferred.resolve(false);
};

module.exports = Command;
