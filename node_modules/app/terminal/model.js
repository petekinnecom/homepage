EventEmitter = require('events').EventEmitter;
Processor = require('app/terminal/processor');
Queue = require('app/utils/work_queue');

function Model(){
  this.events = new EventEmitter();
  this.queue = new Queue(10);
  this.lines = [];

  this.win = add.bind(this, 'win');
  this.log = add.bind(this, 'log');
  this.warn = add.bind(this, 'warn');

  this.defaultProcessor = new Processor();
  this.currentProcessor = this.defaultProcessor;
}

Model.prototype.input = function(input) {
  var options = {
    enqueue: false,
    data: { promptName: this.currentProcessor.name}
  };

  add.call(this, 'input', input, options );

  try {
    process.call(this, input);
  }
  catch(e) {
    this.warn(e.message);
    endProcess.call(this);
  }
};

Model.prototype.setInput = function(input) {
  this.events.emit('setInput', input);
};

Model.prototype.run = function(){
  this.events.emit('run');
};

Model.prototype.interrupt = function(){
  this.currentProcessor = this.defaultProcessor;
};

Model.prototype.close = function(){
  this.events.emit('close');
};

//private, must be bound

//
//options:
//  enqueue: boolean
//  data: options for display
//
var add = function(type, text, options) {

  var line = {
    type: type,
    text: text,
    data: options && options.data
  };

  var displayLine = function(){
    this.lines.push(line);
    this.events.emit('lineAdded', line);
  };

  if (options && !options.enqueue){
    displayLine.call(this);
  }
  else {
    this.queue.push(displayLine.bind(this));
  }
};

// A Processor must return another Processor or
// a falsey value.  False indicates that the processor
// has terminated.  There is no stack, so a Processor
// cannot have a subProcessor.

var process = function(input) {
  this.events.emit('processStarted');
  this.currentProcessor = this.currentProcessor.process(input) || this.defaultProcessor;
  endProcess.call(this);
};

var endProcess = function(){

  var endEvent = function(){
    this.events.emit('processEnded', this.currentProcessor.name);
  };

  this.queue.push(endEvent.bind(this));
};

// singleton, because it will be easier
// than trying to pass the context around
// through asyncronous event handlers (e.g.,
// on url change...)

module.exports = new Model();
